#!/usr/bin/perl

# tForth disassembler for Canon Cat
# Usage: ./fdis [-w] rom_file [address_or_symbol]
#
# rom_file is a pre-interleaved ROM file generated by interleave_rom.
# address may be hexadecimal starting with 0x or 0X. Otherwise the
# symbol is looked up and resolved for you.
#
# If -w is given, then all words in the rom_file are extracted and the
# symbol argument is ignored.
#
# fdis cannot currently disassemble 68K code, and patched out or stub words
# that immediately call into Forth next are marked.
#
# (C)2024 Cameron Kaiser - BSD license
# oldvcr.blogspot.com
# for the 1.74 ROMs ONLY - adjust addresses for the below

# ends with encoded token $7f7f
@dicts = (hex("23b9"), hex("2416"), hex("3ea0c"));
$tokentable = hex("03e0");

eval "use bytes";
sub decode {
	# translated from the Cat ROM
	# dbb2	move.l (a7)+,d0
	#	add.b d0,d0
	#	lsr.l #1, d0
	#	move.l d0,-(a7)
	#	jmp (a4)
	my $val = shift;
	my $top = $val & 65280;
	my $bottom = $val & 255;
	return (($top | (255 & ($bottom + $bottom))) >> 1);
}
sub soffsetc {
	my $base = shift;
	my $offs = shift;
	return $base + (($offs > 127) ? ($offs - 256) : $offs);
}
sub soffsetw {
	my $base = shift;
	my $offs = shift;
	return $base + (($offs > 32767) ? ($offs - 65536) : $offs);
}

if ($ARGV[0] eq '-w') {
	shift @ARGV;
	$words = 1;
} else { $words = 0; }

($rom, $adr) = (@ARGV);
die("usage: $0 [-w] rom_file [address_or_symbol]\n") if (!length($rom));
undef $/;
open(K, "$rom") || die("unable to open $rom: $!\n");
@rom = unpack("C*", <K>);
close(K);

if ($adr =~ /^0[xX]/) {
	$adr = hex(substr($adr, 2));
} elsif ($adr =~ /^[#\+][0-9]+$/) {
	$adr = 0+substr($adr, 1);
} else {
	die("usage: $0 [-w] rom_file [address_or_symbol]\n")
		if (!length($adr) && !$words);

	# try a lookup (also handles -w)
	DICTS: foreach $w (@dicts) {
		my $daddr = $w;
		DENTRY: for (;;) {
			$nadr = $rom[$daddr++] << 8 | $rom[$daddr++];
			last DENTRY if ($nadr == hex("7f7f"));

			my $str = '';
			my $len = $rom[$daddr++];
			# bit 7: this is a length byte
			die(sprintf("unexpected length byte %02x at %04x\n",
					$len, --$daddr)) if (!($len & 128));
			# get string and compare
			# bit 6: immediate
			# bit 5: reserved
			# treat zero as 32 length, per tForth manual
			$len &= 31; $len = 32 if (!$len);
			for($i=0; $i<$len; $i++) {
				$str .= chr($rom[$daddr++]);
			}
			if ($words) {
				push(@wwords, $str);
				next DENTRY;
			}
			last DICTS if ($str eq $adr);
		}
		$nadr = -1;
	}
	if($words) {
		print STDOUT join(" ", sort @wwords)."\n";
		exit 0;
	}
	die("could not find symbol $adr in $rom\n") if ($nadr == -1);
	
	# now find the token's execution address
	$nadr = &decode($nadr);
	printf STDOUT "token = 0x%04x\n", $nadr;
	if ($nadr > 4095) {
		print STDOUT "special system variable instantiated at runtime\n";
		exit 0;
	}
	$jadr = $tokentable + $nadr + $nadr + $nadr;
	die("assertion: token table value overflowed ROM\n")
		if ($jadr > scalar(@rom));
	$adr = $rom[$jadr] << 16 | $rom[$jadr+1] << 8 | $rom[$jadr+2];
}

die(
sprintf("illegal effective address $adr (0x%08x, token offset 0x%08x)\n",
		$adr, $jadr)) if ($adr >= scalar(@rom));

$iword = $rom[$adr++] << 8 | $rom[$adr++];
if ($iword == hex("4e94")) { # i.e., jmp (a4)
	printf "%08x %04x <stubbed out routine>\n", ($adr-2), $iword;
	exit;
}
if ($iword != hex("4ed3")) { # i.e., jmp (a3)
	printf "%08x %04x <68000 code>\n", ($adr-2), $iword;
	exit;
}

OPCODE: for(;;) {
	$opadr = $adr; $b = $rom[$adr++];
	# autopromote if a tierN or intN byte is present
	if ($b < 32) {
		$b = ($b << 8) | $rom[$adr++];
		printf STDOUT "%08x %04x ", $opadr, $b;
	} else {
		printf STDOUT "%08x %02x   ", $opadr, $b;
	}
	
	# name lookup
	STCID: foreach $w (@dicts) {
		my $daddr = $w;
		YRTNED: for (;;) {
			$nadr = $rom[$daddr++] << 8 | $rom[$daddr++];
			last YRTNED if ($nadr == hex("7f7f"));
			$nadr = &decode($nadr);

			my $str = '';
			my $len = $rom[$daddr++];
			# bit 7: this is a length byte
			die(sprintf("unexpected length byte %02x at %04x\n",
					$len, --$daddr)) if (!($len & 128));
			# get string and compare
			# bit 6: immediate
			# bit 5: reserved
			for($i=0; $i<($len & 31); $i++) {
				$str .= chr($rom[$daddr++]);
			}
			if ($nadr == $b) {
				# got a match

				# special opcodes
				if ($str eq "blit") {
					printf STDOUT "%s 0x%02x\n",
						$str, $rom[$adr++];
				} elsif ($str eq '<bran>' ||
						$str eq '<0bran>' ||
						$str eq '<leave>' ||
						$str eq '<0leave>') {
					printf STDOUT "%s 0x%02x (0x%08x)\n",
						$str, ($arg = $rom[$adr++]),
						&soffsetc($adr-1, $arg);
				} elsif ($str eq "wlit") {
					printf STDOUT "%s 0x%02x%02x\n",
						$str, $rom[$adr++],
						$rom[$adr++];
				} elsif ($str eq '<branl>' ||
						$str eq '<0branl>' ||
						$str eq '<leavel>' ||
						$str eq '<0leavel>') {
					$arg = $rom[$adr++] << 8 |
						$rom[$adr++];
					printf STDOUT "%s 0x%04x (0x%08x)\n",
						$str, $arg, 
						# 84e0-e8 adds to a5 after
						# getting *one* byte
						&soffsetw($adr-1, $arg);
				} elsif ($str eq 'lit') {
					printf STDOUT "%s 0x%02x%02x%02x%02x\n",
						$str,
							$rom[$adr++],
							$rom[$adr++],
							$rom[$adr++],
							$rom[$adr++];
				} elsif ($str eq '<">') {
					# string
					$len = $rom[$adr++];
					printf STDOUT "$str \"";
					for($i=0; $i<$len; $i++) {
						printf STDOUT chr($rom[$adr++]);
					}
					print STDOUT "\"\n";
				} else {
					print STDOUT "$str\n";
				}
				last OPCODE if ($str eq ';' || # may not occur?
					$str eq '<;>' || $str eq '<;lp>');
				last STCID;
			}
		}
		$nadr = -1;
	}
	#die(sprintf("unknown opcode %04x at %04x\n", $b, --$adr))
	#	if ($nadr == -1);
	if ($nadr == -1) {
		printf STDOUT "????\n";
	}
}
